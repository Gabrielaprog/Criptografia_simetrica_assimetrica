# -*- coding: utf-8 -*-
"""Criptografia.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_sL5XfYBVi27o8H8x3dnBfdEyCTwRj9N
"""

# Tarefa 1.1

!pip install pycryptodome
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
from Crypto.Random import get_random_bytes

# Dados fornecidos
key = bytes.fromhex("240B31B44A27BEC5062B3A74C63271A4")  # Chave AES em hexadecimal
ciphertext = bytes.fromhex("EF794476D605765572683CE849FBD4555CE8EC1382019662E277F31B8035E285787C1DA9D2CC5B3441F5CB900C41BA70902A932209C3966B83FB4387ABBC95E0")  # Texto cifrado
iv = bytes.fromhex("C4AB0DF3D808D72AAADBC68206483B18")  # IV em hexadecimal

# Inicializar o AES no modo CBC
cipher = AES.new(key, AES.MODE_CBC, iv)

# Decifrar o texto cifrado
plaintext_with_padding = cipher.decrypt(ciphertext)

# Remover o padding PKCS7
try:
    plaintext = unpad(plaintext_with_padding, AES.block_size)
    # Exibir texto claro sem padding
    print('Resultado Tarefa 1.1')
    print()
    print(f"Texto claro (sem padding): {plaintext.decode('utf-8')}")
except ValueError:
    print("Erro ao remover o padding. O texto cifrado pode não ter padding adequado ou o preenchimento pode ter sido feito de forma incorreta.")

print('---------------------------------------------------------------------------------------------------------------')

# Tarefa 1.2

from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import base64
from Crypto.Util.Padding import pad
backend = default_backend()

chave = bytes.fromhex("33A18467DB4AF474B051523A73DDA955") # transformando chave em bytes
dados = 'Gabriela Silveira Trindade Rodrigues'.encode() # transformando texto claro em bytes
hex_dados = dados.hex() # transformando texto claro em hexadecimal
iv = get_random_bytes(16) # gerando iv de 16 de bytes
hex_iv = iv.hex() # transformando iv em hexadecimal
bloco = 16
dados = pad(dados, bloco)

# Inicializar o AES no modo CTR

cipher = Cipher(algorithms.AES(chave), modes.CTR(iv), backend=backend)

encryptor = cipher.encryptor()

mensagem_cifrada = encryptor.update(dados) + encryptor.finalize() # cifrando o texto claro

msg_hexa = mensagem_cifrada.hex() # transformando texto cifrado em hexadecimal


print('Resultado Tarefa 1.2')
print('vetor de inicialização em hexadecimal: ', hex_iv)
print('texto cifrado (em formato hexadecimal): ', msg_hexa)
print('--------------------------------------------------------------------------------------------------')

# Tarefa 2.1

import random

# Definindo os parâmetros fornecidos
p = 1041607122029938459843911326429539139964006065005940226363139  # Número primo p
g = 10  # Base g

# Gerar valor aleatório b (com no mínimo 40 dígitos)
b = random.randint(10**39, p-1)

# Calcular B = g^b % p
B = pow(g, b, p)

# Exibir os valores
print('Resultado Tarefa 2.1')
print()
print(f"Valor de b (em decimal): {b}")
print(f"Valor de B (em decimal): {B}")
print('--------------------------------------------------------------------------------------------')


# Tarefa 2.2

# Definindo o valor de A enviado por Alice
A = 105008283869277434967871522668292359874644989537271965222162

# Calcular v = A^b % p
v = pow(A, b, p)

# Exibir o valor de v
print('Resultado Tarefa 2.2 ')
print()
print(f"Valor de v (em decimal): {v}")
print('--------------------------------------------------------------------------------------------')


# Tarefa 2.3

import hashlib

# Gerar o hash SHA-256 de v
v_str = str(v).encode('utf-8')  # Converter v para string e depois para bytes
hash_object = hashlib.sha256(v_str)  # Calcular o hash SHA-256
hash_hex = hash_object.hexdigest()  # Obter o valor hexadecimal do hash
print(hash_hex)

# Extrair os primeiros 128 bits (32 caracteres hexadecimais)
k_hex = hash_hex[:32]

# Exibir a chave k
print('Resultado Tarefa 2.3')
print()
print(f"Chave k (em hexadecimal): {k_hex}")